import{_ as c,W as d,X as r,Y as o,Z as e,$ as s,a0 as n,D as i}from"./framework-b4edc447.js";const l={},p=n(`<h1 id="通过命令限制docker的资源使用" tabindex="-1"><a class="header-anchor" href="#通过命令限制docker的资源使用" aria-hidden="true">#</a> 通过命令限制docker的资源使用</h1><p><code>--cpus</code> 后面跟着一个浮点数，代表容器最多使用的核数，可以精确到小数点二位，也就是说容器最小可以使用 <code>0.01</code> 核 CPU。比如，我们可以限制容器只能使用 <code>1.5</code> 核数 CPU：</p><p>如果设置的 <code>--cpus</code> 值大于主机的 CPU 核数，docker 会直接报错：</p><p>如果多个容器都设置了 <code>--cpus</code> ，并且它们之和超过主机的 CPU 核数，并不会导致容器失败或者退出，这些容器之间会竞争使用 CPU，具体分配的 CPU 数量取决于主机运行情况和容器的 CPU share 值。也就是说 <code>--cpus</code> 只能保证在 CPU 资源充足的情况下容器最多能使用的 CPU 数，docker 并不能保证在任何情况下容器都能使用这么多的 CPU（因为这根本是不可能的）。</p><p>现在的笔记本和服务器都会有多个 CPU，docker 也允许调度的时候限定容器运行在哪个 CPU 上。比如，我的主机上有 4 个核，可以通过 <code>--cpuset</code> 参数让容器只运行在前两个核上：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">--rm</span> <span class="token parameter variable">-it</span> --cpuset-cpus<span class="token operator">=</span><span class="token number">0,1</span> stress <span class="token parameter variable">--cpu</span> <span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>--cpuset-cpus</code> 参数可以和 <code>-c --cpu-shares</code> 一起使用，限制容器只能运行在某些 CPU 核上，并且配置了使用率。</p><p>限制容器运行在哪些核上并不是一个很好的做法，因为它需要实现知道主机上有多少 CPU 核，而且非常不灵活。除非有特别的需求，一般并不推荐在生产中这样使用。</p><h1 id="内存资源" tabindex="-1"><a class="header-anchor" href="#内存资源" aria-hidden="true">#</a> 内存资源</h1><p><strong>默认情况下，docker 并没有对容器内存进行限制</strong>，也就是说容器可以使用主机提供的所有内存。这当然是非常危险的事情，如果某个容器运行了恶意的内存消耗软件，或者代码有内存泄露，很可能会导致主机内存耗尽，因此导致服务不可用。对于这种情况，docker 会设置 docker daemon 的 OOM（out of memory） 值，使其在内存不足的时候被杀死的优先级降低。另外，就是你可以为每个容器设置内存使用的上限，一旦超过这个上限，容器会被杀死，而不是耗尽主机的内存。</p><p>限制内存上限虽然能保护主机，但是也可能会伤害到容器里的服务。如果为服务设置的内存上限太小，会导致服务还在正常工作的时候就被 OOM 杀死；如果设置的过大，会因为调度器算法浪费内存。因此，合理的做法包括：</p><ul><li>为应用做内存压力测试，理解正常业务需求下使用的内存情况，然后才能进入生产环境使用</li><li>一定要限制容器的内存使用上限</li><li>尽量保证主机的资源充足，一旦通过监控发现资源不足，就进行扩容或者对容器进行迁移</li><li>如果可以（内存资源充足的情况），尽量不要使用 swap，swap 的使用会导致内存计算复杂，对调度器非常不友好</li></ul><p>在 docker 启动参数中，和内存限制有关的包括（参数的值一般是内存大小，也就是一个正数，后面跟着内存单位 <code>b</code>、<code>k</code>、<code>m</code>、<code>g</code>，分别对应 bytes、KB、MB、和 GB）：</p><ul><li><code>-m --memory</code>：容器能使用的最大内存大小，最小值为 4m</li><li><code>--memory-swap</code>：容器能够使用的 swap 大小</li><li><code>--memory-swappiness</code>：默认情况下，主机可以把容器使用的匿名页（anonymous page）swap 出来，你可以设置一个 0-100 之间的值，代表允许 swap 出来的比例</li><li><code>--memory-reservation</code>：设置一个内存使用的 soft limit，如果 docker 发现主机内存不足，会执行 OOM 操作。这个值必须小于 <code>--memory</code> 设置的值</li><li><code>--kernel-memory</code>：容器能够使用的 kernel memory 大小，最小值为 4m。</li><li><code>--oom-kill-disable</code>：是否运行 OOM 的时候杀死容器。只有设置了 <code>-m</code>，才可以把这个选项设置为 false，否则容器会耗尽主机内存，而且导致主机应用被杀死</li></ul><p>关于 <code>--memory-swap</code> 的设置必须解释一下，<code>--memory-swap</code> 必须在 <code>--memory</code> 也配置的情况下才能有用。</p><ul><li>如果 <code>--memory-swap</code> 的值大于 <code>--memory</code>，那么容器能使用的总内存（内存 + swap）为 <code>--memory-swap</code> 的值，能使用的 swap 值为 <code>--memory-swap</code> 减去 <code>--memory</code> 的值</li><li>如果 <code>--memory-swap</code> 为 0，或者和 <code>--memory</code> 的值相同，那么容器能使用两倍于内存的 swap 大小，如果 <code>--memory</code> 对应的值是 <code>200M</code>，那么容器可以使用 <code>400M</code> swap</li><li>如果 <code>--memory-swap</code> 的值为 -1，那么不限制 swap 的使用，也就是说主机有多少 swap，容器都可以使用</li></ul><h1 id="限制磁盘的读写速率" tabindex="-1"><a class="header-anchor" href="#限制磁盘的读写速率" aria-hidden="true">#</a> 限制磁盘的读写速率</h1><p>除了权重之外，docker 还允许你直接限制磁盘的读写速率，对应的参数有：</p><ul><li><code>--device-read-bps</code>：磁盘每秒最多可以读多少比特（bytes）</li><li><code>--device-write-bps</code>：磁盘每秒最多可以写多少比特（bytes）</li></ul><p>上面两个参数的值都是磁盘以及对应的速率，格式为 <code>&lt;device-path&gt;:&lt;limit&gt;[unit]</code>，<code>device-path</code> 表示磁盘所在的位置，限制 <code>limit</code> 为正整数，单位可以是 <code>kb</code>、<code>mb</code> 和 <code>gb</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--device</span> /dev/sda:/dev/sda --device-read-bps /dev/sda:1mb ubuntu:16.04 <span class="token function">bash</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>另外两个参数可以限制磁盘读写频率（每秒能执行多少次读写操作）：</p><ul><li><code>--device-read-iops</code>：磁盘每秒最多可以执行多少 IO 读操作</li><li><code>--device-write-iops</code>：磁盘每秒最多可以执行多少 IO 写操作</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--device</span> /dev/sda:/dev/sda --device-read-iops /dev/sda:100 ubuntu:16.04 <span class="token function">bash</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h1 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h1><p>从上面的实验可以看出来，CPU 和内存的资源限制已经是比较成熟和易用，能够满足大部分用户的需求。磁盘限制也是不错的，虽然现在无法动态地限制容量，但是限制磁盘读写速度也能应对很多场景。</p>`,26),t={href:"https://github.com/moby/moby/issues/26767",target:"_blank",rel:"noopener noreferrer"},m={href:"https://github.com/moby/moby/issues/37",target:"_blank",rel:"noopener noreferrer"},u={href:"https://github.com/moby/moby/issues/4763",target:"_blank",rel:"noopener noreferrer"},h=o("p",null,"资源限制一方面可以让我们为容器（应用）设置合理的 CPU、内存等资源，方便管理；另外一方面也能有效地预防恶意的攻击和异常，对容器来说是非常重要的功能。如果你需要在生产环境使用容器，请务必要花时间去做这件事情。",-1);function b(k,v){const a=i("ExternalLinkIcon");return d(),r("div",null,[p,o("p",null,[e("至于网络，docker 现在并没有给出网络限制的方案，也不会在可见的未来做这件事情，因为目前网络是通过插件来实现的，和容器本身的功能相对独立，不是很容易实现，扩展性也很差。docker 社区已经有很多呼声，也有 issue 是关于网络流量限制的: "),o("a",t,[e("issue 26767"),s(a)]),e("、"),o("a",m,[e("issue 37"),s(a)]),e("、"),o("a",u,[e("issue 4763"),s(a)]),e("。")]),h])}const y=c(l,[["render",b],["__file","通过命令限制docker的资源使用.html.vue"]]);export{y as default};
