import{_ as r,W as t,X as o,Y as a,Z as e,$ as n,a0 as i,D as l}from"./framework-b4edc447.js";const p={},c=a("h1",{id:"高可用prometheus方案thaos调研",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#高可用prometheus方案thaos调研","aria-hidden":"true"},"#"),e(" 高可用Prometheus方案thaos调研")],-1),u=a("h2",{id:"依赖环境",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#依赖环境","aria-hidden":"true"},"#"),e(" 依赖环境：")],-1),d={href:"https://prometheus.io/",target:"_blank",rel:"noopener noreferrer"},h={href:"https://thanos.io/tip/thanos/storage.md/",target:"_blank",rel:"noopener noreferrer"},m=i(`<h2 id="thaos的组成" tabindex="-1"><a class="header-anchor" href="#thaos的组成" aria-hidden="true">#</a> Thaos的组成：</h2><p>遵循 KISS 和 Unix 哲学，Thanos 由一组组件组成，每个组件都扮演着特定的角色。</p><ul><li>Sidecar：连接到 Prometheus，读取其数据进行查询和或将其上传到云存储。</li><li>Store Gateway：在云存储桶内提供指标。</li><li>Compactor：对存储在云存储桶中的数据进行压缩、降采样和应用保留。</li><li>Receiver：从 Prometheus 的远程写入 WAL 接收数据，将其公开和 或上传到云存储。</li><li>Ruler/Rule：根据 Thanos 中的数据评估记录和警报规则，以进行说明和/或上传。</li><li>Querier/Query：实现 Prometheus 的 v1 API 以聚合来自底层组件的数据。</li><li>Query Frontend：实现 Prometheus 的 v1 API 将其代理到 Query，同时缓存响应和可选的查询日拆分。</li></ul><h3 id="sidecar" tabindex="-1"><a class="header-anchor" href="#sidecar" aria-hidden="true">#</a> Sidecar：</h3><p>Thanos 通过 Sidecar 进程与现有的 Prometheus 服务器集成，Sidecar 进程与 Prometheus 服务器在同一台机器或同一 Pod 中运行。Sidecar 的目的是将 Prometheus 数据备份到对象存储桶中，并让其他 Thanos 组件通过 gRPC API 访问 Prometheus 指标。</p><p>Docker 启动命令示例</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span>  <span class="token punctuation">\\</span>
    <span class="token parameter variable">-v</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>/prometheus0_eu1.yml:/etc/prometheus/prometheus.yml <span class="token punctuation">\\</span>
    <span class="token parameter variable">--name</span> prometheus-0-sidecar-eu1 <span class="token punctuation">\\</span>
    <span class="token parameter variable">-u</span> root <span class="token punctuation">\\</span>
    quay.io/thanos/thanos:v0.28.0 <span class="token punctuation">\\</span>
    sidecar <span class="token punctuation">\\</span>
    --http-address <span class="token number">0.0</span>.0.0:19090 <span class="token punctuation">\\</span>
    --grpc-address <span class="token number">0.0</span>.0.0:19190 <span class="token punctuation">\\</span>
    --reloader.config-file /etc/prometheus/prometheus.yml <span class="token punctuation">\\</span>
    <span class="token parameter variable">--prometheus.url</span> http://172.17.0.1:9090
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当使用 <code>--shipper.upload-compacted</code> 标志运行 sidecar 时，它将在启动时从 Prometheus 本地存储同步所有旧的现有块。（适用于已经在用的Prometheus）</p><p>外部标签</p><p>Prometheus 允许配置给定 Prometheus 实例的“外部标签”。这些旨在全局识别该实例的角色。由于 Thanos 旨在聚合所有实例的数据，因此提供一组一致的外部标签变得至关重要！ 每个 Prometheus 实例都必须有一组全局唯一的标识标签。例如，在 Prometheus 的配置文件中：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">global</span><span class="token punctuation">:</span>
  <span class="token key atrule">external_labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">region</span><span class="token punctuation">:</span> eu<span class="token punctuation">-</span>west
    <span class="token key atrule">monitor</span><span class="token punctuation">:</span> infrastructure
    <span class="token key atrule">replica</span><span class="token punctuation">:</span> A
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置完Sidecar后，修改配置文件会自动重载，<code> --reloader.config-file</code>标志运行Sidecar时，会自动重载Prometheus的配置文件，还有其他相关参数，控制探测间隔等。</p><h3 id="querier-query" tabindex="-1"><a class="header-anchor" href="#querier-query" aria-hidden="true">#</a> Querier/Query</h3><p>在为一个或多个Prometheus配置了Sidecar后，想使用Thanos 的全局查询层来同时评估针对所有实例的 PromQL 查询，需要配置Querier/Query。</p><p>查询组件是无状态和水平可扩展的，可以部署任意数量的副本。一旦连接到 Sidecars，它会自动检测需要为给定的 PromQL 查询联系哪些 Prometheus 服务器。Thanos Querier 还支持了 Prometheus 的官方 HTTP API，因此可以与 Grafana 等外部工具一起使用。它还服务于 Prometheus 的 UI 的衍生产品，用于临时查询和存储状态。</p><p>在多个Prometheus中去重</p><p>Query 组件还能够对从 Prometheus HA 对收集的数据进行重复数据删除。这需要配置 Prometheus 的 global.external_labels 配置块来识别给定 Prometheus 实例的角色。一个典型的选择就是简单地使用标签名称“replica”，同时让值随心所欲。例如，您可以在 Prometheus 的配置文件中设置以下内容：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">global</span><span class="token punctuation">:</span>
  <span class="token key atrule">external_labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">region</span><span class="token punctuation">:</span> eu<span class="token punctuation">-</span>west
    <span class="token key atrule">monitor</span><span class="token punctuation">:</span> infrastructure
    <span class="token key atrule">replica</span><span class="token punctuation">:</span> A
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="store-gateway" tabindex="-1"><a class="header-anchor" href="#store-gateway" aria-hidden="true">#</a> Store Gateway</h3><p>当 Sidecar 将数据备份到您选择的对象存储中时，您可以减少 Prometheus 保留并减少本地存储。然而，我们需要一种方法来再次查询所有的历史数据。Store Gateway通过实现与Sidecar相同的 gRPC 数据API 来实现这一点，但使用它可以在对象存储桶中找到的数据对其进行支持。就像 sidecars 和查询节点一样，store gateway 暴露了 StoreAPI 并且需要被 Thanos Querier 发现。</p><p>store gateway 占用少量磁盘空间用于缓存对象存储中数据的基本信息。这很少会超过几千兆字节，用于缩短重启时间。它很有用，但不需要在重新启动时保留它。</p><h3 id="compactor" tabindex="-1"><a class="header-anchor" href="#compactor" aria-hidden="true">#</a> Compactor</h3><p>本地 Prometheus 安装会定期压缩旧数据以提高查询效率。由于 Sidecar 会尽快备份数据，因此我们需要一种方法将相同的过程应用于对象存储中的数据。</p><p>Compactor只需扫描对象存储并在需要时处理压实。同时，它负责创建数据的下采样副本，以加快查询速度。</p>`,24);function v(k,b){const s=l("ExternalLinkIcon");return t(),o("div",null,[c,u,a("p",null,[e("需要一个或多个v2.2.1以上版本的"),a("a",d,[e("Prometheus"),n(s)]),e(" ，Thaos支持多种"),a("a",h,[e("对象存储"),n(s)]),e("用于长期存储Prometheus的监控数据")]),m])}const _=r(p,[["render",v],["__file","高可用Prometheus方案thaos调研.html.vue"]]);export{_ as default};
