import{_ as t,W as r,X as i,Y as a,Z as e,$ as d,a0 as s,D as l}from"./framework-b4edc447.js";const o={},h=s(`<h1 id="给别人准备的面试题" tabindex="-1"><a class="header-anchor" href="#给别人准备的面试题" aria-hidden="true">#</a> 给别人准备的面试题</h1><h3 id="自我介绍" tabindex="-1"><a class="header-anchor" href="#自我介绍" aria-hidden="true">#</a> 自我介绍</h3><h3 id="用过哪些版本的linux-知道哪些版本的linux" tabindex="-1"><a class="header-anchor" href="#用过哪些版本的linux-知道哪些版本的linux" aria-hidden="true">#</a> 用过哪些版本的Linux，知道哪些版本的Linux</h3><h3 id="zabbix和prometheus的区别" tabindex="-1"><a class="header-anchor" href="#zabbix和prometheus的区别" aria-hidden="true">#</a> zabbix和prometheus的区别</h3><p>用过openresty吗？和NGINX有啥区别</p><p>OpenResty® 是一个<code>基于 Nginx </code>与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关，从而将 Nginx 有效地变成一个<code>强大的通用 Web 应用平台</code>。</p><h3 id="redis键值" tabindex="-1"><a class="header-anchor" href="#redis键值" aria-hidden="true">#</a> Redis键值</h3><p>Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，</p><h3 id="值支持五种数据类型-字符串、列表、集合、散列表、有序集合。" tabindex="-1"><a class="header-anchor" href="#值支持五种数据类型-字符串、列表、集合、散列表、有序集合。" aria-hidden="true">#</a> <strong>值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</strong></h3><h3 id="inode" tabindex="-1"><a class="header-anchor" href="#inode" aria-hidden="true">#</a> inode</h3><p>Linux如何删除一个文件名中有空格的文件</p><h3 id="如何查看linux系统版本" tabindex="-1"><a class="header-anchor" href="#如何查看linux系统版本" aria-hidden="true">#</a> 如何查看linux系统版本</h3><div class="language-lua line-numbers-mode" data-ext="lua"><pre class="language-lua"><code><span class="token operator">~</span>$ cat <span class="token operator">/</span>etc<span class="token operator">/</span>os<span class="token operator">-</span>release
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="uptime" tabindex="-1"><a class="header-anchor" href="#uptime" aria-hidden="true">#</a> uptime</h3><h3 id="http状态码403" tabindex="-1"><a class="header-anchor" href="#http状态码403" aria-hidden="true">#</a> http状态码403</h3><p>403 Forbidden 是HTTP协议中的一个HTTP状态码（Status Code）。 403状态码意为服务器成功解析请求但是客户端没有访问该资源的权限。</p><h3 id="elk的组成以及功能" tabindex="-1"><a class="header-anchor" href="#elk的组成以及功能" aria-hidden="true">#</a> ELK的组成以及功能</h3><ul><li>Elasticsearch：是一个搜索和分析引擎</li><li>Logstash：是一个服务端的数据预处理管道，它可以同时收集、转换多个数据源的数据，并且发送给Elasticsearch</li><li>Kibana：是一个Web平台，将Elasticsearch的数据用表格和图片的形式展现出来，以供分析</li><li>Filebeat: 是一个日志文件托运工具，在服务器上安装之后，Filebeat会监控日志目录或者指定的日志文件，追踪读取这些文件，将收集到的日志数据发送给Logstash。（除了Logstash，它也可以发送给Elasticsearch、Kafka、Redis等）</li></ul><p>prometheus是怎么发送告警的，alertmanager是怎么配置的？grafana是怎么权限控制的</p><p>与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p><table><thead><tr><th>数据类型</th><th>可以存储的值</th><th>操作</th><th>应用场景</th></tr></thead><tbody><tr><td>STRING</td><td>字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作</td><td>做简单的键值对缓存</td></tr><tr><td>LIST</td><td>列表</td><td>从两端压入或者弹出元素 对单个或者多个元素进行修剪， 只保留一个范围内的元素</td><td>存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据</td></tr><tr><td>SET</td><td>无序集合</td><td>添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素</td><td>交集、并集、差集的操作，比如交集，可以把两个人的粉丝列表整一个交集</td></tr><tr><td>HASH</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对 获取所有键值对 检查某个键是否存在</td><td>结构化的数据，比如一个对象</td></tr><tr><td>ZSET</td><td>有序集合</td><td>添加、获取、删除元素 根据分值范围或者成员来获取元素 计算一个键的排名</td><td>去重但可以排序，如获取排名前几名的用户</td></tr></tbody></table><h3 id="linux-有哪些系统日志文件" tabindex="-1"><a class="header-anchor" href="#linux-有哪些系统日志文件" aria-hidden="true">#</a> Linux 有哪些系统日志文件？</h3><p>比较重要的是 <code>/var/log/messages</code> 日志文件。</p><p>Docker 在 Linux 的底层技术有：<code>Namespaces</code><strong>（资源隔离）</strong>、<code>CGroups</code> <strong>（资源限制）</strong>、<code>UnionFS</code> <strong>（联合文件系统）</strong>。其中：</p><h3 id="docker命令" tabindex="-1"><a class="header-anchor" href="#docker命令" aria-hidden="true">#</a> docker命令</h3><p>容器生命周期管理: run、start/stop/restart、kill、rm、pause/unpause</p><p>容器操作：ps、inspect、top</p><p>镜像仓库：login、pull、push、search</p><p>本地镜像管理：images、rmi、tag、build、history</p><h3 id="docker-和虚拟机的区别" tabindex="-1"><a class="header-anchor" href="#docker-和虚拟机的区别" aria-hidden="true">#</a> Docker 和虚拟机的区别？</h3><p>容器技术和虚拟机都提供了<strong>环境隔离</strong>的功能。不同的是。容器是运行在操作系统上的一个进程，它和其他应用程序是共享内核的，由<strong>操作系统</strong>提供虚拟化隔离功能；而虚拟机则是完完全全<strong>另</strong>起了个操作系统，将环境隔离的更加彻底。</p><h3 id="docker的网络类型" tabindex="-1"><a class="header-anchor" href="#docker的网络类型" aria-hidden="true">#</a> Docker的网络类型</h3><h4 id="bridge-模式" tabindex="-1"><a class="header-anchor" href="#bridge-模式" aria-hidden="true">#</a> bridge 模式</h4><p>Docker 在主机上会创建一个 <code>docker0</code> 的网桥，每当有容器要创建时，便会为容器分配一个独立的网卡，然后桥接到虚拟网桥上。这其实是一对虚拟网卡，一端放在容器里，另一端放在 <code>docker0</code> 网桥里。当一端有数据达到时，就会把数据包转发到另一端上，这就实现了网络通信。</p><h4 id="host-模式" tabindex="-1"><a class="header-anchor" href="#host-模式" aria-hidden="true">#</a> host 模式</h4><p>在建一个容器时，一般会为容器分配一个独立的 <strong>Network Namespace</strong> 以进行网络隔离。如果我们使用了 <code>Host</code> 模式，则不再分配 Network Namespace，而是和<strong>宿主机</strong>共用一个 Network Namespace。此时容器将不再拥有自己的虚拟网卡、IP 和端口，而是和宿主机<strong>共用</strong>一个 IP 和端口。</p><h4 id="none-模式" tabindex="-1"><a class="header-anchor" href="#none-模式" aria-hidden="true">#</a> none 模式</h4><p>使用 none 模式的容器拥有属于自己的 Network Namespace，但不做任何网络配置。它和宿主机以及其他容器是不互通的。如果需要和外部通信，则需要自定义网络驱动程序，自己添加网卡、配置 IP 等。</p><h3 id="keepalived原理" tabindex="-1"><a class="header-anchor" href="#keepalived原理" aria-hidden="true">#</a> Keepalived原理</h3><p>Keepalived：Keepalived是一个保证集群高可用的服务软件，用来防止单点故障，使用VRRP协议实现。在master和backup之间通过master主动降低自己的权值或者backup检测到master出现故障时，backup将会接管master的工作，继续服务。 HAproxy：HAProxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。HAProxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理。HAProxy运行在当前的硬件上，完全可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中，同时可以保护你的web服务器不被暴露到网络上。 heartbeat+ DRBD： heartbeat （Linux-HA）的工作原理：heartbeat最核心的包括两个部分，心跳监测部分和资源接管部分，心跳监测可以通过网络链路和串口进行，而且支持冗 余链路，它们之间相互发送报文来告诉对方自己当前的状态，如果在指定的时间内未收到对方发送的报文，那么就认为对方失效，这时需启动资源接管模块来接管运行在对方主机上的资源或者服务。 Distributed Replicated Block Device(DRBD)是一个用软件实现的、无共享的、服务器之间镜像块设备内容的存储复制解决方案。 数据镜像：实时、透明、同步（所有服务器都成功后返回）、异步（本地服务器成功后返回）</p><h3 id="k8s-的健康检查机制是什么" tabindex="-1"><a class="header-anchor" href="#k8s-的健康检查机制是什么" aria-hidden="true">#</a> k8s 的健康检查机制是什么？</h3><p>k8s 主要通过提供下面两种探针(probe)来进行 Pod 的健康检测：</p><ul><li>livenessProbe(存活探针)：用来确定什么时候要重启容器，例如通过一个 HTTP GET 请求来判断容器是否健康存活。</li><li>readinessProbe(就绪探针)：有时候，应用程序会暂时性的不能提供通信服务。（例如启动加载大文件）。在这种情况下，既不想杀死应用程序，也不想给它发送请求。Kubernetes 提供了就绪探测器来发现并缓解这些情况，设置后，流量将不会打到 Service 上。</li></ul><h3 id="简述一下dns的解析过程" tabindex="-1"><a class="header-anchor" href="#简述一下dns的解析过程" aria-hidden="true">#</a> 简述一下DNS的解析过程</h3>`,44),c={href:"http://qq.com",target:"_blank",rel:"noopener noreferrer"},p=s(`<h3 id="mysql主从复制原理" tabindex="-1"><a class="header-anchor" href="#mysql主从复制原理" aria-hidden="true">#</a> MySQL主从复制原理</h3><p>1.数据库有个bin-log二进制文件，记录了所有sql语句。</p><p>2.我们的目标就是把主数据库的bin-log文件的sql语句复制过来。</p><p>3.让其在从数据的relay-log重做日志文件中再执行一次这些sql语句即可。</p><h3 id="shell" tabindex="-1"><a class="header-anchor" href="#shell" aria-hidden="true">#</a> shell</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token variable">$0</span>    命令行中的脚本名字
<span class="token variable">$1</span>    第一个命令行参数
<span class="token variable">$2</span>    第二个命令行参数
…<span class="token punctuation">..</span>    …….
<span class="token variable">$9</span>    第九个命令行参数
<span class="token variable">$#</span><span class="token comment">#    命令行参数的数量</span>
<span class="token variable">$*</span>    所有命令行参数，以空格隔开
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>-ne —比较两个参数是否不相等 -lt —参数1是否小于参数2 -le —参数1是否小于等于参数2 -gt —参数1是否大于参数2 -ge —参数1是否大于等于参数2 -f — 检查某文件是否存在（例如，if [ -f &quot;filename&quot; ]） -d — 检查目录是否存在</p>`,7),m=a("p",null,[e('整数比较： -eq 等于 if [ "'),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"a"),a("mi",{mathvariant:"normal"},'"'),a("mo",null,"−"),a("mi",null,"e"),a("mi",null,"q"),a("mi",{mathvariant:"normal"},'"')]),a("annotation",{encoding:"application/x-tex"},'a" -eq "')])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.7778em","vertical-align":"-0.0833em"}}),a("span",{class:"mord mathnormal"},"a"),a("span",{class:"mord"},'"'),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),a("span",{class:"mbin"},"−"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),a("span",{class:"mord mathnormal"},"e"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"q"),a("span",{class:"mord"},'"')])])]),e('b" ] -ne 不等于 if [ "'),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"a"),a("mi",{mathvariant:"normal"},'"'),a("mo",null,"−"),a("mi",null,"n"),a("mi",null,"e"),a("mi",{mathvariant:"normal"},'"')]),a("annotation",{encoding:"application/x-tex"},'a" -ne "')])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.7778em","vertical-align":"-0.0833em"}}),a("span",{class:"mord mathnormal"},"a"),a("span",{class:"mord"},'"'),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),a("span",{class:"mbin"},"−"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6944em"}}),a("span",{class:"mord mathnormal"},"n"),a("span",{class:"mord mathnormal"},"e"),a("span",{class:"mord"},'"')])])]),e('b" ]')],-1),u=a("p",null,[e('字符串比较： = 等于 if [ "'),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"a"),a("mi",{mathvariant:"normal"},'"'),a("mo",null,"="),a("mi",{mathvariant:"normal"},'"')]),a("annotation",{encoding:"application/x-tex"},'a" = "')])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6944em"}}),a("span",{class:"mord mathnormal"},"a"),a("span",{class:"mord"},'"'),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),a("span",{class:"mrel"},"="),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6944em"}}),a("span",{class:"mord"},'"')])])]),e('b" ] == 与=等价')],-1),b=s('<h3 id="prometheus配置文件里面的relable标签" tabindex="-1"><a class="header-anchor" href="#prometheus配置文件里面的relable标签" aria-hidden="true">#</a> Prometheus配置文件里面的relable标签</h3><p>文件发现</p><h3 id="alertmanager接收者匹配方式" tabindex="-1"><a class="header-anchor" href="#alertmanager接收者匹配方式" aria-hidden="true">#</a> alertmanager接收者匹配方式</h3><h3 id="假如一个定时任务没有被执行-怎么排查" tabindex="-1"><a class="header-anchor" href="#假如一个定时任务没有被执行-怎么排查" aria-hidden="true">#</a> 假如一个定时任务没有被执行，怎么排查</h3><h3 id="nginx配置文件中root与alias主要区别" tabindex="-1"><a class="header-anchor" href="#nginx配置文件中root与alias主要区别" aria-hidden="true">#</a> nginx配置文件中root与alias主要区别？</h3><p>在于nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。 root的处理结果是：root路径＋location路径 alias的处理结果是：使用alias路径替换location路径 alias是一个目录别名的定义，root则是最上层目录的定义。 还有一个重要的区别是alias后面必须要用“/”结束，否则会找不到文件的。。。而root则可有可无~~</p>',6);function g(x,k){const n=l("ExternalLinkIcon");return r(),i("div",null,[h,a("p",null,[e("解答： 1、在浏览器中输入www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址("),a("a",c,[e("qq.com"),d(n)]),e(")给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。 6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。")]),p,m,u,b])}const f=t(o,[["render",g],["__file","给别人准备的面试题.html.vue"]]);export{f as default};
