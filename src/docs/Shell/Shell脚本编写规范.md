# Shell脚本编写规范

## [Shell十三问](https://github.com/wzb56/13_questions_of_shell)

+ 脚本名以.sh结尾，名称尽量见名之意，比如ClearLog.sh Clear_Log.sh clearlog.sh SerRestart+ sh Ser_Restart.sh;
+ 尽量使用UTF-8编码，注释及输出尽量使用英文；
+ 一般给到执行权限，但一些关于变量的配置文件不用加执行权限；
+ 执行的时候可以使用bash 执行，或者使用bash -x执行，可以直观的显示具体的执行过程；
+ 脚本首行使用/bin/bash,没有空格，不带任何选项；
+ 第二行为空格，或者是添加一行空注释
+ 接着开始注释内容：文件名、功能描述、作者、最后修改日期、版本号以及一些说明，还加上邮箱/手机号做为+ 系，如果可以，需要加上版权声明；
+ 注释内容之后空一行开始定义shell脚本中的变量；
+ 脚本内的变量定义，尽量使用大写，或者大小写驼峰写法,或者使用下划线连接的方式。变量名要见名之意，避+ a,b,c类似的定义，变量的定义前后不要用空格。
+ 如果是整形，需要使用declare -i来声明。
+ 如果是数组，则需要使用declare -a来声明。
+ 如果是只读变量，则需要使用declare -r来声明。
+ 变量值尽量使用双引号引起来，如果要使用强引用，如变量值中包含$符号，则使用”单引号引起来。
+ 如果要将命令的执行结果赋值给变量，则使用反引号，或者使用$().

```bash
# 如果脚本在执行的时候需要大段输出提示信息，可是使用以下方式：
    cat << EOF
    This scripts used for XXX
    Usage:$0 [option]
    Pls be careful.
    Enjoy Yourself.
    EOF
    # 如果只是单行提示信息，可是使用echo的方式，可以添加颜色：
    echo “Welcome to use my script”
```
+ 如果需要创建临时文件，可以使用如下方式： mktemp -d /tmp/file$$
其名称以 /tmp/file 开头并以当前 shell 进程的进程 ID 结尾。使用 $$ 可以获取当前 shell 进程的进程 ID。其中，-d 选项表示创建一个目录，不加 -d 选项则表示创建一个文件。例如：
```bash
mktemp -d /tmp/file$$
```
执行此命令后，将会在 /tmp 目录下创建一个以 file 开头，以当前进程 ID 结尾的临时目录。例如，如果当前 shell 进程的进程 ID 是 1234，那么创建的目录名就是 /tmp/file1234。

使用临时文件或目录可以避免命名冲突和文件泄露等问题，因为它们只在当前进程的生命周期内存在，并在进程退出时自动删除。

+ 条件测试的时候，尽量使用[[]],而不用[]或者test，因为[[]]功能会更强大
+ 算数运算使用(())或者是中括号，但是记得括号里面的变量不要再加$
```bash
((12+i))
而非((12+$i))
```

+ 想要获取当前脚本所在目录，可以使用
```bash
ScriptDir=$(cd $(dirname $0) && pwd)
```
> 具体解释如下：
> 
> $(dirname $0)：获取当前脚本的目录名，$0 表示当前脚本的文件名（包含路径），dirname 命令可以获取该> 文件名所在的目录名。
> 
> cd $(dirname $0)：进入当前脚本所在的目录。
> 
> pwd：获取当前目录的绝对路径。
> 
> ScriptDir=$(cd $(dirname $0) && pwd)：将当前目录的绝对路径赋值给变量 ScriptDir。
> 
> 因此，执行这个命令后，变量 ScriptDir 将会保存当前脚本所在的目录的绝对路径。这个命令常用于获取脚本> 所在目录的路径，方便在脚本中使用其他文件或目录的相对路径。

+ 经常尝试不同的方法

你在写脚本时碰到一个问题，然后你找到了一种独特的解决方法。下一次你偶然又碰到类似的问题，这时，不要再用以前你用过的方法来解决。试试另外一种方法吧。如果某一天再次遇到这种情况，再试试其它方法。
```bash
例如：

if [ $? - eq 0 ]
then
    echo "Success"
fi
另一种方法：
[ $? - eq 0 ] && echo "Success"
```

## 
